title: 我对闭包的初步理解
date: 2012-08-18 23:09:00
tags: [javascript]
category: 技术

---

这是我在海豚浏览器初学web前端的时候，针对javascript闭包做的一次初步总结。可以说是我这个新人眼里对闭包的一个具体形象。

# 闭包的中心思想

1. 内部函数引用了外部函数的变量；
2. 当这个内部函数被调用时，就创建了一个闭包。此时，包括函数内部的代码逻辑以及作用域链，都将被引用。
3. 因为作用域链也被引用，所以外部函数里被用到的变量，在函数调用完毕后不会被回收，而是留在内存中以供闭包（也就是被调用的内部函数）所使用。

<!-- more -->

# 闭包的状态模拟
初学者如我，对闭包的概念很容易含糊不清。同事说有人研究了一年都搞不懂，不知是不是真的，反正听起来挺可怕。所以在网上看了一些帖子后，摘取并总结了几个比较形象的状态模拟，希望能够让闭包的“长相”更加清晰一些。

## 数学

* `(1, 5)`是一个区间
* 但对其做分析、计算时，往往会用到`1`和`5`这两个**不属于这个区间的值**
* 此时，`(1, 5)`就是在`[1, 5]`这个区间，甚至是`(-∞, ∞)`内创建的闭包。

## 生活

* 某人去政府找A部门办事
* A部门推B部门，B部门推C部门...这并不是一个闭包
* A部门带着这个人，帮他去找政府内部的B部门、C部门办事儿，这样才算一个闭包。

## 项目

* 假设项目组是一个外部函数
* Dev, UX, Tester是这个函数里声明的局部变量，而PM则是返回供调用的内部函数
* 用户反馈，上层意见，市场拓展等一系列需求，都必须先集中到PM身上，然后PM再去协调项目组内部的Dev, UX, Tester来完成工作。
* PM这样的一个角色，可以很形象地看成是一个闭包。

## 图形模拟
![自己乱画的闭包图...](../../../../img/closure1.png)

# 函数作用域
上文在初步讲解闭包的时候，提到了函数的**作用域链**的概念。这也是javascript里特殊的地方，也是和闭包的概念息息相关的地方。

* 函数的执行依赖于变量的作用域，这个作用域是在函数定义时决定的（而非函数调用时）。
* JS不同于类似C语言等编程语言的**块级作用域**，取而代之地使用了**函数作用域**。

## 块级作用域VS函数作用域

* 块级作用域：花括号内每一段代码都有各自的作用域，变量在声明它的代码段之前是不可见的。它是一个“有或无”的差别。
* 函数作用域：变量在被声明的函数体以及这个函数体嵌套的任意函数体内都是可见的，只是可能没有被初始化。它不是“有或无”的差别，而是“是否有值”的差别。
* 简单地说，JS里有着“声明提前”的规则。不论你在当前函数体的哪个位置声明了变量，JS都会当做是在当前函数体的开头进行的声明。（注意，只是声明提前，赋值什么的都不是。）

## 作用域链

* 调用JS函数对象，不仅仅是调用函数内部的代码逻辑，还会包括代码当前的作用域链。
* 作用域链就像一个对象列表，它包含了这段作用域上的所有变量。
* 作用域链的最顶端就是客户端Javascript的全局对象windows

本人再次手拙，画一幅模拟图图来表示啥是作用域链。
![自己乱画的作用域链图...](../../../../img/closure2.png)

对着上图来说，每一个函数在被创建的时候，都会生成三个内置属性：

* **AO** (函数内部的变量及参数)
* **this** (调用函数的对象)
* **scope** （作用域，指向外层函数的[AO+scope]，就这样形成作用域链）

JS到函数中找变量的时候，会首先从当前的AO里找，如果找到了就用。
如果找不到，就会从scope外链到上一层作用域（也就是紧邻的外层函数），从它的AO里再次找起。
以此类推，不断地往作用域链顶端找变量，直到最顶部的window。如果window也没有定义这个变量，就宣告失败，没有定义这个变量。

## 关于全局变量

这时候有人就会问了：把上面提到的相关的变量都定义到全局岂不省事儿？
**问得好。**

* 命名规范有风险，命名重用率低，语义化会越来越复杂。
* 全局空间里其他函数可能会误用这些函数。
* 全局对象过于庞大，影响访问速度。（变量的取值是遍历的）

所以我在自己做项目时非常推崇前端代码模块化的风格，尤其是担忧命名空间的这类问题。

# 闭包的场景举例（随时更新补充）

## 保护函数内的变量安全 	
	
若要访问外部函数里定义的变量，只能通过调用的内部函数才能进行访问，可见传统的存取器。

## 在内存中维持一个变量
	
当一个变量或一个对象没有被任何一个地方引用时，js的垃圾回收机制会自动将其摧毁并回收。
所以，如果希望一个变量在内存中维持，可以利用闭包。
这样即使外层函数被回收掉了，其中定义的变量也因为内部函数用到了，而被保存在内存里。
**这一点是一把双刃剑，闭包的劣势之一就是因为如果滥用这个机制会导致内存污染。**

## 模拟类的私有属性&私有变量
	
```javascript
function Person(name) { //私有属性name
  this.getName = function () {return name;};
  this.setName = function (newName) {name = newName;};
}
var p = new Person('Haihao');
alert(p.getName());  // => 'Haihao'
alert(p.name);       // => undefined 因为Person类没有name属性
p.name = 'Quan'      //              给p添加公开的属性
alert(p.getName())   // => 'Haihao'  但是不会改变getName返回值
alert(p.name)        // => 'Quan'	
p.setName('Pingyuan')//              改变私有的name属性
alert(p.getName())   // => 'Pingyuan'
alert(p.name)        // => 'Quan'
```

来看以上示例代码，虽然都叫`name`， 但闭包指向的是变量name在内存中的值与地址，而并不是'name'这个名字。所以并不会和公开声明的name属性有冲突。
	
这样一来，除非使用存取器，否则无法改变和获取Person类的实例p的name值！
	
## 在执行函数之前，为要执行的函数提供参数。

众所周知，javascript里面两个特殊的函数`setTimeout(func, wait)`和`setInterval(func, wait)`的第一个参数是js代码串，直接调用是没法传参数的。
我最喜欢的js库[underscore.js](http://underscorejs.org/)里有这么一个方法，叫做`_.delay(func, wait, *arguments)`。
它是怎么支持传参数的呢？
	
```javascript
// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.

_.delay = function(func, wait) {
var args = slice.call(arguments, 2);
return setTimeout(function(){ return func.apply(null, args); }, wait);
};

```
	
其作用和`setTimeout(func, wait)`是一样的，但在`_.delay`的实现方式里，用到了闭包。
	
我们额外传进去的参数（\*arguments）作为setTimeout调用的匿名函数外层的变量被保留，并在返回的`func`调用时被传进去。而我们传进的方法（第一个参数）在setTimeout里被囊括在一个匿名函数中调用，并传参。
	
## 循环绑定事件
	
给个常见案例

```javascript
for (var i = 0; i < link.length; i++) {
  link[i].onclick = function () {alert(i)}
}
// => 所有click事件都输出 i == link.length

for (var i = 0; i < link.length; i++) {
  link[i].onclick = (function () {
    return function () {
      alert(i)
    }
  })(i)
}
// => 输出从0到link.length - 1
```

## 仅使用一次的函数
	


