title: '提升页面性能的有效方式'
date: 2014-03-11 23:32:10
tags: [javascript, css, 性能优化, http协议]
category: 性能优化
---
##前言

本文是读[Best Practices for Speeding Up Your Web Site](https://developer.yahoo.com/performance/rules.html)后，感触非常深，然后参考[@Big军](http://my.oschina.net/hmj)的译文，结合自己的思考和看法，将一些要点总结了下来，所以并不如原文那么详细。

##最小化HTTP请求
80%用户的时间都耗费在了前端上，而其中的大部分都是用来下载各种网页组件。减少这些组件的数量，就能够减少HTTP请求的数量，从而加快网页速度。这是加速网页的关键所在。
简化页面设计不失为一个好办法，但两全其美的办法有吗？下面是一些既能够支持丰富的页面设计，也能有效地减少HTTP请求。

* 组合文件（Combined files）
* CSS精灵（CSS Sprites）
* 图片maps(Image Maps） *不推荐*
* 内联图片（inline Images） *不推荐*

减少页面中HTTP的数量是优化页面的起点，对于初次访问者，这是提升性能最好的方向。

##使用外部的CSS和JavaScript

* 简单的HTML文档使用内联的js和css无可厚非。
* 复杂试图的HTML则适合使用外部的js和css。

以上需要找到一个平衡点。

<!-- more -->
##减少DNS查询

**还待研究**

##避免重定向

* 重定向可以通过使用状态码301和302完成，所有重定向所需的信息都在头部，浏览器会自动将用户带到Location所指明的URL中去。
* 重定向会降低用户体验。在用户和HTML文档之间插入一个重定向，会延迟页面中的所有东西。
* 容易被忽略的重定向，如果本该有`/`的路径丢失了`/`，那么会发生一个到带有`/`路径的重定向。

##使Ajax可缓存

**还待研究**

##延迟加载组件
在渲染页面时，有其他的组件和图片是非必需的。

例如JavaScript，应用于一些拖拽或者动画的，都可以延迟加载。
另外，例如LazyLoad之类的理念，可以让你页面之外的图片延迟加载。

##预加载组件
与上一个命题不矛盾，因为这都是分情况的。有这么几种预加载情况可以让你预加载，在不增加渲染页面的速度同时也让用户后面的动作感觉反应变快：

* onload事件触发后就去加载某些东西
* 用户做了某些动作，能让你预判出下一步时，预加载下一步需要的东西

##减少DOM元素的数量
复杂的页面意味着会下载更多的字节，也会降低JavaScript访问DOM的速度。

##跨域分隔组件

分隔组件会让你能够最大化地并行下载组件。但确保你的主域名不要超出2-4个的范围，因为以上提到了一条“减少DNS查询”，这会损耗性能的。

##减少iFrame的数量

理解iframes的工作方式是十分重要的，只有这样我们才能更高效的利用iframes。

`iFrame`优点:

* 帮助减少类似于徽章和广告这样的第三方内容
* 安全沙盒（不懂）
* 并发下载脚本

`iFrame`缺点:
* 尽管空白，但损耗十分昂贵。
* 阻碍页面加载
* 非语义化

##不要有404

HTTP请求是十分宝贵的，所以产生一个HTTP请求却得到一个无响应是非常浪费的。


##使用CDN
CDN(Content Delivery Network)是一个跨多地点更加高效分发内容到用户的分布式web服务器的集合。它能够分发内容到具体用户的服务器，这是根据网络距离的测量来决定的（也就是最快的）。
这比所有组件都来自自己固定的服务器要好得多，而且使用大型CDN服务商的服务（[Akamai Technologies](http://www.akamai.com/), [EdgeCast](http://www.edgecast.com/), 或者 [level3](level3)），也节省了自己搭建CDN的很大的成本。

##添加一个 Expires 或者一个 Cache-Control 头部信息
这条原则包括两方面：

* 对于静态组件：通过设置未来的Expires 信息头来实现 "Never expire"策略
* 对于动态组件：通过合理的使用Cache-Control 头来帮助浏览器有选择性的请求。

##使用GZIP压缩组件
Gzip是当前最流行的和最有效的压缩方法。它是由GNU项目开发并被RFC1952标准化的。唯一其它你可能用到的压缩方式是deflate，但是它可能相对于Gzip，效率要低，知名度要低。

Gzip压缩通常会减少响应的大小的大约70%。

尽可能多的压缩文件，是一种减轻网页重量和加速用户体验的较为简单的方式。

##在Ajax请求中使用GET
理由是POST要2步（先发请求头，再发数据），而GET只需1步。

##避免`<img>`标签里src的空白

不论是标签形式还是给`Image`对象赋值`src=''`，这都会导致同一个问题，那就是多余的请求。

**但是**，我仍坚持语义化的观点，获取数据用GET，发送请求用POST。

另外，IE中GET的数据不得超过2K，所以该POST时还是POST吧。


##将样式文件放在头部

* HTML规范强烈推荐我们这么做
* 我们发现把css放到文档头部会让网页加载得更快。因为这样可以让页面逐渐加载。
* 把样式表放到接近底部的问题是它阻止了页面元素的逐渐显示。这样还会导致“flash of unstyled content”，即在样式表加载之前页面内容是以没有样式的形式显示出来的。待加载完样式后，页面重绘，内容一闪即改变了样式表现。

##选择`<link>`而不是`@import`

`@import`的表现与将样式文件放在页面底部的表现是一样的。

##避免使用滤镜

IE专有的AlphaImageLoader滤镜，意在修复在IE7之前版本中存在的半透明真彩色PNDS问题。这个滤镜的问题在于，它会阻碍渲染，并且在图片下载的过程中冻结浏览器。不仅仅是图片，而是对于每一个应用滤镜的元素而言，它都会增加内存损耗，所以它引起的问题是多样的。


##优化CSS精灵

* 在CSS精灵中将你的图片水平放置通常会比垂直放置产生一个更小的文件大小。
* 结合相似颜色到同一个CSS精灵中能够帮助你降低颜色数，最理想的情况是256中颜色，来适合PNG8
* 如果要对移动设备友好，那么在一个CSS精灵中不要在图片之间留出太大的缝隙。这不会过多影响文件大小，但是手机会用更少的内存来将图片解压成像素图。比如，100\*100的图像是1万像素，1000\*1000就是一百万像素。

##不要在HTML中缩放图片
需要显示多大的图，就用多大的图。利用html缩放图片很损耗性能。


##使favicon.ico小且可缓存

* favicon.ico是一张放置在你的服务器根下面的图片。

* 它是个必须的“弊病”，因为尽管你并不在意它，浏览器仍旧会请求它，所以最好不要用404 Not Found响应。

* 同样，由于在同一台服务器上，cookie在每次favicon.ico被请求也会被一起发送。

* 这个图片同样会妨碍下载顺序，例如在IE中当你在onload中请求额外组件时，favicon.ico会在其它组件之前优先被下载。


##将脚本放在底部

* 不同于其他资源，浏览器对script的下载是非并行的，并且会阻塞其他资源的下载。
* HTTP/1.1协议中规定浏览器和同一host之间只建立最多两个连接，也就是说允许的最大并行度为2（当然，对IE和Firefox来说，你都可以通过修改浏览器的设置来扩大这个并行度，但是，并发数越高，占用CPU和带宽就越大）。
* 为了防止后面的js文件依赖了前面未加载好的js而出错，浏览器采用了这个非并行策略。

##压缩JavsScript和CSS
缩减操作指的是移除代码中不必要的字符来缩小体积进而改善加载时间的操作。代码缩减后，所有的注释将被移除，不必要的空白字符（space, newline, and tab）将被移除。对于Javascript来说，这改善了响应时间效果，因为所下载的文件大小缩减了。


##删除重复的JavaScript
重复的js在许多浏览器中仍会重复发出请求。

##尽量少地访问DOM

* 缓存已经访问过的元素
* "离线"更新节点，然后把它们添加到DOM树上
* 除非万不得已，避免使用Javascript来实现自适应布局

##使用“智能”的事件处理
* 使用事件委托，利用事件冒泡机制在父元素上捕获事件，而不是在一个个的子元素上反复绑定。
* 不一定要等到onload之后再来运行脚本，有时候DOMContentLoaded事件就可以了。

##保持组件小于25kb

iPhone不会缓存超过25K的组件。
更多信息请查看由Wayne Shea 和 Tenni Theurer发表的["Performance Research, Part 5: iPhone Cacheability - Making it Stick"](http://yuiblog.com/blog/2008/02/06/iphone-cacheability/)

##将组件打包成一个复合文档
还待研究


##减少cookie的大小

浏览器中，关于cookie的信息是在请求头部中进行交换的。使其足够小是用来降低它对响应时间的影响。

要获取更多信息，请查看Tenni Theurer 和 Patty Chi发表的 ["When the Cookie Crumbles"](http://yuiblog.com/blog/2007/03/01/performance-research-part-3/) 。该研究的精要是：

* 消除不必要的cookies
* 保持cookies的体积尽可能小，以降低对用户响应时间的影响
* 记住要在合适的域名级别下设置cookies，以避免对子域的影响。
* 设置一个合适的失效日期。过早的失效日期或者是马上消除cookies会提高用户的响应时间。

##为组件使用不带cookie的域名

浏览器请求图片时，请求头部带上的cookie对服务器来说是无用的，反而会引起网络堵塞。

所以你需要保证在无cookie的环境下去请求静态资源，比如用一个子域名来放图片。






